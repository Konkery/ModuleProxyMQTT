class ClassProxyMQTT{constructor(_mqtt){this._MQTT=_mqtt,this._Subs={sensor:{}},this._SkipData=!1,this._DataSkipInterval=null,Object.on("sensor-sub",(topicName,channelId)=>{this._Subs.sensor[channelId]=topicName}),Object.on("sensor-data",data=>{this.OnSensorData(data)})}TestReceive(msg){Object.emit(msg.com,msg.arg)}OnSensorData(data){this._DataSkipInterval&&this._SkipData||Object.keys(this._Subs.sensor).filter(subID=>data[subID]).forEach(subID=>this.Send(this._Subs.sensor[subID],data[subID]))}AddSubs(_serviceName,_serviceSubs){if(!this._Subs[_serviceName]||"object"!=typeof _serviceSubs)return!1;Object.keys(_serviceSubs).forEach(chId=>{this._Subs[_serviceName][chId]=_serviceSubs[chId]})}RemoveSubs(_serviceName,_serviceSubs){if(!this._Subs[_serviceName]||"object"!=typeof _serviceSubs)return!1;_serviceSubs.forEach(chId=>{delete this._Subs[_serviceName][chId]})}Receive(_data){let command_obj=null;try{command_obj=JSON.parse(_data)}catch(e){throw new err("Incorrect JSON data")}Object.emit(command_obj.com,command_obj.arg)}Send(topicName,data){this._MQTT.publish(topicName,data)}SetPubMaxFreq(_freq){return!("number"!=typeof _freq||_freq<0)&&(this._DataSkipInterval=setInterval(()=>{this._SkipData=!this._SkipData},1/_freq*1e3),!0)}}exports=ClassProxyMQTT;